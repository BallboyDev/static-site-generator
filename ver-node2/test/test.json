{"dir_1":{"title":"심심한 개발자의 취미 개발","file":"","index":1,"count":14,"children":{"dir_13":{"title":"svelte 정리","file":"","index":13,"count":7,"children":{"post_23":{"file":"Directive","index":23,"path":"_post/심심한 개발자의 취미 개발_1/svelte 정리_13/Directive.md","fold":["1","13"],"date":20250424,"prev":22,"next":24,"content":"\n## directive\n\n### bind:\n- 데이터는 일반적으로 부모에서 자식으로 흘러값니다. `bind:` 지시문은 데이터를 지식에서 부모로 반대 방향으로 흐르게 합니다.\n\n- Function bindings\n    - `bind:property={get, set}`과 같이 getter, setter 함수를 사용할 수 있습니다.\n    - 단 읽기 전용 바인딩의 get의 값은 null이어야 합니다.\n\n```html\n<input bind:value={value} />\n\n<input bind:value={\n    () => value,\n    () => value = v.toLowerCase()\n}/>\n\n<div\n    bind:clientWidth={null, redraw}\n    bind:clientHeight={null, redraw}\n>...</div>\n```\n\n- `<input bind:value>`\n    - bind:value 지시문은 속성의 값을 바인딩합니다.\n    - 바인딩 값이 null이거나 정의 되지 않은 경우 defaultValue 속성을 사용할 수 있습니다. (5.6.0 이후)\n\n- `<input bind:checked>`\n    - 체크박스와 라디오 입력은 `bind:checked` 로 묶을 수 있습니다.\n    - 바인딩 값이 null이거나 정의되지 않은 경우 defaultChecked 속성을 사용할 수 있습니다. (5.6.0 이후)\n\n- `<input bind:group>`\n    - 함께 작동하는 입력은 bind:group을 사용할 수 있습니다.\n\n- `<input bind:files>`\n    - `type=\"file\"`인 경우 bind:files를 사용하여 선택한 파일의 파일 목록을 가져올 수 있습니다.\n\n- `<select bind:value>`\n    - `<select>` 값 바인딩은 선택된 `<option>`의 값 속성에 해당한다.\n\n### use:\n- use:action은 스벨트에서 사용되는 용어로써, 돔 노드의 요소가 생성, 업데이트, 삭제될 때 실행되는 함수를 의미한다.\n- 일반적으로 요소가 마운트 해제될 때 상태를 재설정할 수 있도록 $effect를 사용합니다.\n\n### transition:\n- transition은 상태 변화의 결과로 DOM의 변화시 사용되는 요소 입니다."},"post_24":{"file":"Runtime","index":24,"path":"_post/심심한 개발자의 취미 개발_1/svelte 정리_13/Runtime.md","fold":["1","13"],"date":20250424,"prev":23,"content":"\n# Runtime\n\n## Store\n- 스벨트에는 여러 컴포넌트의 상태를 공유하기 위해 store 라는 구조를 제공한다.\n- 스토어에 대한 참조가 있을 때마다 구성 요소 내부의 해당 값에 `$` 문자로 접두사를 붙이면 액세스 할 수 있습니다.\n- 스토어 변수에 값을 할당하기 위해서는 쓰기 가능한 저장소여야 하며, 이는 저장소의 .set 메서드로 호출됩니다.\n\n~~~svelte\n<script>\n    import { writable } from 'svelte/store';\n\n    const count = writable(0)\n    console.log($count)\n\n    count.set(1)\n    console.log($count)\n\n    $count = 2\n    console.log($count)\n</script>\n~~~\n\n### svelte/store\n- writable\n    - 외부 구성 요소에서 설정할 수 있는 값을 가진 저장소를 생성하는 기능입니다. 추가 설정 및 업데이트 방법을 통해 객체로 생성됩니다\n    - `set(val)`은 스토어 값에 val을 설정합니다.\n    - `subscribe(callback)`는 스토어를 구독하여 스토어의 값이 변하면 새로운 값을 인수로 callback을 실행합니다. 반환값으로 구독을 중지하는 함수를 반환합니다.\n    - `update(update)`은 현재 값을 기반으로 스토어의 값을 새 값으로 업데이트, 현재 값을 인수로 updater가 실행, 반환 값으로 새 값을 스토어에 설정 합니다.\n\n    ```js\n    import { writable } from 'svelte/store'\n\n    const count = writable(0)\n\n    count.subscribe((value) => {console.log(value)})\n    count.set(1)\n    count.update((n) => {return n + 1})\n    ```"},"post_20":{"file":"life cycle","index":20,"path":"_post/심심한 개발자의 취미 개발_1/svelte 정리_13/life cycle.md","fold":["1","13"],"date":20250424,"prev":19,"next":21,"content":"\n## life Cycle\n### 라이프 사이클\n- .svelte 파일로 작성된 컴포넌트는 최종적으로 자바스크립트 파일로 변환되어 브라우저에서 실행된다. 이 실행(런타임) 처리의 흐름을 컴포넌트의 라이프 사이클 이라고 한다.\n- svelte5의 라이프 사이클은 생성과 파괴라는 두 가지 주요 과정으로 구성됩니다.\n- 생성/마운트은(는) 컴포넌트가 초기화되며 DOM에 렌더링되는 시점입니다. 컴포넌트가 필요한 렌더링 효과를 설정하며, 초기 상태와 UI가 준비됩니다.\n- 파괴/언마운트는 컴포넌트가 DOM에서 제거되기 전, 리소스를 정리하고 이벤트 리스너나 구독을 해제해야 할 때 호출됩니다.\n\n- 라이프 사이클 함수\n    - 스벨트는 라이프 사이클 과정에서 특정 타이밍에 실행할 작업을 지정할 수 있는 onMount, onDestory와 상태가 반영될 때 까지 기다리는 tick을 제공하며 이들을 라이프 사이클 함수라고 한다.\n    - svelte5 이후 로는 사용되지 않는 beforeUpdate, afterUpdate 함수가 있었다.\n\n- onMount\n    - onMount는 컴포넌트가 작성되고 최초 렌더링이 완료된 직후에 호출되는 처리를 설정하는 함수이다.\n\n- onDestory\n    - onDestory는 onMount와 반대로, 컴포넌트가 삭제되기 직전에 호출되는 처리를 설정하는 함수다\n\n- tick\n    - tick은 스벨트가 제공하는 특수한 함수로, 컴포넌트 내부에 보류 상태의 DOM 업데이트가 있으면 업데이터가 끝날 떄까지 기다리는 Promise를 반환한다.\n\n```html\n<script>\n    import { onMount, onDestory, tick } from 'svelte'\n\n    onMount(() => {\n        console.log('the component has mounted')\n\n        // onMount에서 비동기 함수 로직(async/await)을 넣을 경우 async 함수의 리턴은 promise이므로 return 익명 함수가 무시된다. 그래서 비동기 함수가 있는 경우에는 onDestory 함수를 사용해야 된다.\n        // return () => { console.log('the component is being destoryed') }\n    })\n\n    onDestory(() => {\n        console.log('the component is being destoryed')\n    })\n\n    let clicked = $state(false);\n\n    const handleClick = async () => {\n        // 상태 변경\n        clicked = true;\n\n        // clicked 값의 상태가 변경 될때까지 대기\n        await tick();\n\n        // clicked 의 값이 변경 되지 않았을때 실행시 <canvas> 요소를 찾을 수 없어 에러 발생\n        const canvas = document.getElementById(\"canvas\");\n        const ctx = canvas.getContext(\"2d\");\n\n        ctx.fillStyle = \"#ddd\";\n        ctx.fillRect(0, 0, 100, 100);\n        ctx.fillRect(100, 100, 200, 200);\n    };\n</script>\n\n<h3>{temp}</h3>\n\n<div>\n    <button onclick={handleClick}>표시</button>\n</div>\n\n{#if clicked}\n    <canvas id=\"canvas\" width=\"200\" height=\"200\"></canvas>\n{/if}\n```\n\n### beforeUpdate / afterUpdate\n- beforeUpdate와 afterUpdate는 각각 컴포넌트의 DOM 구조가 업데이트 되기 직전과 직후에 호출 되는 처리를 등록하는 함수이다.\n\n```html\n<script>\n    import { beforeUpdate, afterUpdate } from 'svelte'\n\n    beforeUpdate(() => {\n        console.log('the component is about to update')\n    })\n\n    afterUpdate(() => {\n        console.log('the component just updated')\n    })\n</script>\n```"},"post_21":{"file":"runes","index":21,"path":"_post/심심한 개발자의 취미 개발_1/svelte 정리_13/runes.md","fold":["1","13"],"date":20250424,"prev":20,"next":22,"content":"\n## Runes\n- 룬은 svelte 컴파일러를 제어하기 위해 `.svelte` 및 `.svelte.ts` 파일에서 사용하는 기호 입니다. Svelte를 하나의 언어로 생각한다면, 룬은 그 문법의 일부로, 키워드에 해당합니다.\n\n### 특징\n1. 컴파일러 지시문\n    - 룬은 svelte 컴파일러가 코드를 분석하고 변환하는 방식을 제어합니다.\n2. 반응성 강화 \n    - 반응성 관리, 상태 변경, 그리고 의존성 추적 등을 명확하게 정의 할 수 있습니다.\n3. 가독성 향상\n    - 복잡한 동작을 간결하게 표현하며, 코드의 의도를 명확히 전달합니다.\n4. 주로 `$`로 시작\n    - 룬은 `$`로 시작하며, 기존 svelte의 반응성 모델을 확장하는 요소를 제공합니다.\n\n### $state\n- $state 룬을 사용하면 반응 상태를 만들수 있습니다.\n- 다른 프레임워크와 달리 상태를 변경하기 위한 API가 존재하지 않습니다. 일반적인 변수를 업데이트 하는 것과 같이 값을 변경할 수 있습니다.\n\n- __디테일한 부분은 더 공부가 필요함__\n\n```html\n<script>\n    let count = $state(0)\n</script>\n\n<button onclick={() => count++}>\n    clicks : {count}\n</button>\n```\n\n### $derived / $derived.by\n- $derived 룬은 state에서 파생된 state를 만들 수 있습니다. derived state는 직접적인 값의 변경이 불가능 합니다.\n- `$derived(...)` 내부의 표현에서는 내부의 상태 변경 문법을 허용하지 않습니다. (ex. count++)\n- `$derived(...)`의 표현식으로는 작성하기 부족한 복잡한 식을 작성해야 할 경우 `$derived.by(...)`를 사용한다.\n- `$derived(expr)` => `$derived.by(() => expr)`\n\n```html\n<script>\n    let count = $state(0);\n    let doubled = $derived(count + 1);\n    let doubledouble = $derived.by(() => {\n        return (doubled * 2) ** 2;\n    });\n</script>\n\n<button onclick={() => count++}> click!! </button>\n\n<p>{count}</p>\n<p>{doubled}</p>\n<p>{doubledouble}</p>\n```\n\n### $effect\n\n```html\n<script>\n    let state = $state(0);\n\n    console.log(\"in component setup : \", $effect.tracking());\n\n    $effect(() => {\n        state;\n        console.log(\"effect\");\n    });\n\n    $effect.pre(() => {\n        state;\n        console.log(\"effect.pre\");\n    });\n\n    $effect(() => {\n        console.log(\"in effect : \", $effect.tracking());\n    });\n</script>\n\n<button\n    onclick={() => {\n        state++;\n        console.log(\"in onclick : \", $effect.tracking());\n    }}>{state}</button\n>\n\n<p>in template : {$effect.tracking()}</p>\n\n```\n\n1. $effect\n    - $effect 룬은 state 또는 derived state값을 추적하고 상태가 변경되었을 경우 함수를 실행합니다.\n    - 리액트와 달리 추척을 위한 값을 따로 선언할 필요가 없이 `$effect(expr)` 내부에 값을 사용하면 된다.\n\n2. $effect.pre\n    - $effect.pre 룬은 상태 값이 변경된 후 DOM 업데이트 전에 코드를 실행하기 위해 사용됩니다.\n    - $effect.pre룬은 $effect룬과 타이밍을 제외한 모든 것이 동일하게 작동합니다.\n\n3. $effect.tracking\n    - $effect.tracking 룬은 해당 코드가 `$effect()`안에서 실행되는지 `template` 코드 안에서 실행되는지 여부를 알려주는 기능입니다.\n\n4. $effect.root\n    - $effect.root 룬은 리소스를 수동으로 관리 할수 있는 범위를 생성하는 룬입니다.\n    - 이 기능은 수동으로 제어하려는 효과에 유용합니다.\n\n### $props\n- $props룬은 컴포넌트에 전달된 props를 선언적이고 간단하게 관리할 수 있도록 제공되는 룬입니다.\n\n- $props의 특징\n    1. 컴포넌트 props 관리\n        - $props는 컴포넌트가 외부로 부터 전달 받은 속성을 선언적으로 정의하고 관리합니다.\n\n    2. 기본값 설정 가능\n        - $props를 사용하면 각 속성에 기본값을 지정할 수 있습니다.\n\n    3. 타입 지정 기능\n        - Typescript와 함께 사용할 경우 props의 타입을 명확히 정희할 수 있습니다.\n\n    4. 자동 반응성\n        - $props에 정의된 속성은 자동으로 반응성을 가지며, 값이 변경될 때 컴포넌트가 갱신됩니다\n\n### $bindable\n- 일반적으로 props는 부모 컴포넌트에서 자식 컴포넌트로 흐릅니다. $bindable 룬을 사용하면 자식 컴포넌트에서 바인딩된 상태값을 변경할 수 있습니다.\n- 하지만 데이터의 흐름과 구조를 복잡하기에 주의해서 사용해야 합니다.\n\n### $inspect\n- $inspect rune은 상태 인수가 변경될 때마다 내부 프로세스가 실행됩니다.\n- $inspect rune은 콜백과 함께 호출할 수 있는 속성을 반환하며, 이 속성은 conols.log 대신 호출됩니다. 콜백에 대한 첫번째 인수는 \"init\" 또는 \"update\"이며, 이후 인수는 $inspect에 전달된 값입니다.\n\n### $host\n- 구성 요소를 사용자 지정 요소로 컴파일 할 때 $host rune은 호스트 요소에 대한 액세스를 제공하므로 사용자 지정 이벤트를 디스패치할 수 있습니다. -> ?\n\n### 기타 룬 (Runes)\n1. $memo\n1. $store\n1. $action\n1. $server"},"post_18":{"file":"svelte Basic","index":18,"path":"_post/심심한 개발자의 취미 개발_1/svelte 정리_13/svelte Basic.md","fold":["1","13"],"date":20250424,"next":19,"content":"\n## Basic\n\n### .svelte 파일 구조\n- 스벨트 컴포넌트는 .svelte 확장자를 사용한다.\n\n```html\n<!-- component.svelte -->\n\n<script>\n    // script code\n    // 타입 스크립트 문법을 사용할때는 <script lang=\"ts\">로 블럭을 시작한다.\n</script>\n\ntemplate code\n\n<style>\n    /* style code */\n</style>\n```\n\n\n### template 기초 문법\n- html 태그\n    - 보통 html 태그는 .svelte 파일의 템플릿에서 그대로 사용한다.\n\n- 동적 컨텐츠\n    - 템플릿 내부에서 `{ code }` 와 같이 사용하면 식의 결과가 표시된다,\n    - `<div>현재 시간은 {new Date()} 입니다.</div>`\n    - 동적 속성\n        - DOM 요소의 속성명과 변수 명이 동일할 때는 다음과 같이 생략 할 수 있다.\n            ```html\n            <script>\n                let href = 'https://svelte.dev/'\n            </sciprt>\n\n            <a {href}>svelte 공식 사이트</a>\n            ```\n        - {...object} 와 같이 스프레드 문법의 스프레드 속성도 사용 가능하다.\n\n### style\n- 스타일 문법\n    - `<style>` 블록에는 일반적인 CSS 문법을 사용한다.\n    - `<style>` 블록에 작성한 스타일은 .svelte 파일에 스코프 범위를 갖는다.\n    - 스코프 범위를 벗어나서 전역으로 스타일을 적용하시 싶을 때는 :global 수식자를 사용한다.\n        ```html\n        <style>\n            /** 이 스타일은 <body>에 적용됨 */\n            :global(body) {\n                background-color: red;\n            }\n\n            /** .class 내부의 모든 <img> 에 이 스타일을 적용(자식/손자 컴포넌트)*/\n            .class :global(img) {\n\n            }\n        </style>\n        ```\n    \n- class 속성을 생략하는 문법\n    - 클래스 속성은 boolean 값에 따른 속성 변경이 일어나는 경우가 잦아 스벨트는 이를 위해 생략 문법을 제공한다.\n    - `class:클래스명={boolean}` 과 같이 사용하면 값이 true d일 때면 클래스명을 class 속성에 추가한다.\n        ```html\n        <li class={active ? 'className' : ''}>TOP</li>\n        <li class:className={active}>TOP</li>\n\n        <!-- 변구명과 클래서명이 동일할 때는 다음과 같이 추가 생략도 가능하다. -->\n        <li class:active>TOP</li>\n        ```\n\n- style 속성 생략 문법\n    ```html\n    <div style=\"color: red\">빨간색</div>\n    <div style:color=\"red\">빨간색</div>\n\n    <div style:color={color}>{color}</div>\n    <div style:color>{color}</div>\n    ```"},"post_19":{"file":"svelte 속성","index":19,"path":"_post/심심한 개발자의 취미 개발_1/svelte 정리_13/svelte 속성.md","fold":["1","13"],"date":20250424,"prev":18,"next":20,"content":"\n## Attribute\n### 속성\n- 속성 생성, 전달, default\n    - 속성을 사용하기 위해서는 속성을 전달받는 측인, 자식 컴포넌트에서 속성을 생성해야 한다.\n    ```html\n    <!-- Button.svelte -->\n    <script>\n        // svelte4 props 선언\n        export let label\n        export let disabled = false;\n\n        // svelte5 props 선언\n        let { label, disabled = false } = $props();\n\n        // svelte5 버전의 runes 문법 추가로 인해 사용하지 않는 문법\n        console.log($$props)\n    </script>\n\n    <button {disabled}>\n        {label}\n    </button>\n\n    <!-- App.svelte -->\n    <script>\n        import Button from './Button.svelte'\n        let buttonLabel = '전송'\n    </script>\n\n    <Button label={buttonLabel} />\n    ```"},"post_22":{"file":"template Syntax","index":22,"path":"_post/심심한 개발자의 취미 개발_1/svelte 정리_13/template Syntax.md","fold":["1","13"],"date":20250424,"prev":21,"next":23,"content":"\n## Template Syntax\n- __Block__\n    - 스벨트의 템플릿에서는 조건 분기나 반복문과 같은 문법을 제공한다.\n    - 블록 문법은 모두 `{#...}` 에서 `{/...}`으로 끝나는 구조를 가진다.\n\n### {#if expression}\n- 조건부로 렌더링 되는 콘텐츠는 `{#if}` 블록으로 감쌀 수 있습니다. \n- 추가 조건은 `{:else if}`으로 추가할 수 있으며, 선택적으로 `{:else}` 절로 끝납니다.\n\n~~~svelte\n{#if expression}\n    <!-- Code1 -->\n{:else if expression}\n    <!-- Code2 -->\n{:else}\n    <!-- Code3 -->\n{/if}\n~~~\n\n### {#each expression}\n- `#each` 에서 배열과 같은 값에 대한 반복 작업을 수행할 수 있습니다. \n- 각 목록 항목을 고유하게 식별해야 하는 키 식을 제공하면 Svelte는 마지막에 항목을 추가하거나 제거하는 대신 이를 사용하여 데이터가 변경될 때 목록을 확신합니다.\n- `#each` 에는 목록이 비어 있는 경우 렌더링이 되는 `{:else}` 절을 사용할 수 있다.\n\n~~~svelte\n{#each expression as name, index (key)}\n    <!-- repeat Code -->\n{/each}\n\n{#each expression as {item, ...rest}, i, {key}}\n    <!-- repeat Code -->\n{/each}\n\n{#each expression, index}\n    <!-- repeat Code -->\n{/each}\n\n{#each expression as name, index (key)}\n    <!-- repeat Code -->\n{:else}\n    <!-- empty Code -->\n{/each}\n~~~\n\n### {#key expression}\n- `#key` 블록은 식의 값이 변경되면 내용을 파괴하고 다시 생성합니다. \n- 구성 요소 주변에 사용하면 구성 요소가 다시 복원되고 다시 초기화 됩니다.\n\n~~~svelte\n{#key expression}\n    <!-- Code -->\n{/key}\n~~~\n\n### {#await expression}\n- `#await` 블록을 사용하면 대기 중, 완료, 거부 세 가지 상태를 분기할 수 있습니다.\n- `:then` 블록과 `:catch` 블록은 생략 가능합니다.\n\n~~~svelte\n{#await expression}\n    <!-- Waiting Code -->\n{:then name} \n    <!-- response Code -->\n{:catch name}\n    <!-- reject Code -->\n{/await}\n\n{#await expression}\n    <!-- Waiting Code -->\n{:then name}\n    <!-- response Code -->\n{/await}\n\n{#await expression then name}\n    <!-- response Code -->\n{/await}\n\n{#await expression catch name}\n    <!-- reject Code -->\n{/await}\n~~~\n\n### {#snippet expression}\n- `#snippet` 블록과 렌더링 태그는 컴포넌트 내부에 재사용 가능한 마크업 코드를 만드는 방법입니다.\n- `#snippet` 블록과 렌더링 태그는 기본 스코프 문법을 따릅니다.\n- `#snippet` 블록은 템플릿 내에서 객체로 다루어 지기에 컴포넌트에 속성 값이나 props 값으로 전달이 가능합니다.\n- 스니펫 문법은 createRawSnippet API를 사용하여 프로그래밍 방식으로 생성할 수 있습니다.\n\n~~~svelte\n{#snippet name1()}\n    <!-- Code1 -->\n{/snippet}\n\n{#snippet name2(param)}\n    <!-- Code2 -->\n{/snippet}\n\n{#snippet name3(param)}\n    <!-- Code3 -->\n{/snippet}\n\n{@render name1()}\n{@render name2(param)}\n{@render name3?.(param)}\n\n<Component header={name1} row={name2}/>\n~~~\n\n### 기타 블럭 문법 \n- {@render ...}\n    - snippet 문법을 렌더링 하기 위해 사용됩니다.\n- {@html ...}\n    - svelte 코드에 HTML 주입하기 위해 사용됩니다.\n- {@const ...}\n    - 로컬 상수를 정의하기 위해 사용됩니다.\n    - 블록의 직계 하위 항목으로만 허용됩니다.\n- {@debug ...}\n    - 특정 변수의 값이 변경 될 때마다 기속되며, 개발 도구가 열려 있는 경우 코드 실행을 일시 중지 합니다.\n\n~~~svelte\n<!-- {@render ...} -->\n{#snippet name1()}\n    <p>name1</p>\n{/snippet}\n{#snippet name2()}\n    <p>name2</p>\n{/snippet}\n\n{@render (value ? name1 : name2)()}\n{@render name2?.()}\n\n<!-- {@heml ...} -->\n<article>\n    {@html content}\n</article>\n\n<!-- {@const ...} -->\n{#each boxes as box}\n    {@const area = box.width * box.height}\n    {box.width} * {box.height} = {area}\n{/each}\n\n<!-- {@debug ...} -->\n{@debug user}\n{@debug user1, user2, user3}\n\n~~~"}}},"dir_11":{"title":"간단 블로그 만들기","file":"","index":11,"count":5,"children":{"post_10":{"title":"0. 블로그 만들기 - 시작하며","file":"0. 블로그 만들기 - 시작하며","index":10,"path":"_post/심심한 개발자의 취미 개발_1/간단 블로그 만들기_11/0. 블로그 만들기 - 시작하며.md","fold":["1","11"],"date":20250320,"prev":9,"next":13,"content":"\n# 0. 블로그 만들기 - 시작하며\n나는 업무나 학습, 일상 생활에서도 마크다운을 자주 활용한다.\n심지어 이력서를 작성할때도 마크다운으로 내용을 정리하고 최종적으로 옮기는 편이다.\n나는 티스토리에서 블로그를 몇 번 운영을 했었는데 부지런함을 떠나서 마크다운 지원이 부실하다는 점이 너무 부정적으로 다가왔다.\n그래서 나만의 블로그를 만들기로 하였다 (난 개발자니까ㅎㅎ)\n앞으로 이 블로그를 기반으로 하나하나 기능을 추가 하며 발전 시켜 보겠다.\n\n> 테마\n> 마크다운으로 작성ㅎ고 폴더 구조 기반의 웹 페이지 제작\n\n## 블로그의 설계\n1. 디자인은 jekyll과 티스토리 스킨, vscode 등에서 디자인을 참고 하였다.\n1. 포스팅은 마크다운으로 작성하고 마크다운을 HTML로 변환하는 방식을 사용한다.\n1. 각 포스팅은 vscode와 같이 트리 구조를 활용한 포스트 접근 방식을 사용한다.\n    - 트리 구조에서 깊이 제한은 없다.\n1. 반응형 블로그 디자인을 목표로 한다.\n1. 개발은 node.js 기반으로 진행하며 마크다운에서 변환된 HTML 파일을 github.io에 직접 올리는 방식으로 포스팅을 진행한다.\n\n## 기능\n### 필수 기능\n1. 마크 다운 to HTML 변환\n1. 포스트 폴더 구조를 트리 구조로 변환하여 Navigator 구현 및 Accordion 기능\n1. 개발 환경과 배포 환경 간의 이미지, css, js 파일의 자동 배포\n1. 모바일 환경을 위한 반응형 디자인\n1. 카테고리별 포스트 개수\n1. 블로그 환경 설정 기능\n\n### 추가 기능\n1. 이전 글, 다음 글 이동 기능\n1. 생성, 수정 기록 표시\n1. 블로그 내 태그 및 검색 기능\n1. 구글 서치 연결\n1. 댓글 기능\n1. 방문 통계 및 back office 구현\n1. 마크다운 to HTML 변환 라이브러리 구현\n    - 발전된 형태의 자동화 컨버터 구현 (이미지 사이즈/정렬, 표 작성 등)"},"post_13":{"title":"1. 블로그 만들기 - 폴더 탐색","file":"1. 블로그 만들기 - 폴더 탐색","index":13,"path":"_post/심심한 개발자의 취미 개발_1/간단 블로그 만들기_11/1. 블로그 만들기 - 폴더 탐색.md","fold":["1","11"],"date":20250322,"prev":10,"next":16,"content":"# 1. 블로그 만들기 - 폴더 탐색\ngithub page에 블로그 제작을 기획하며 핵심 기능으로 2가지를 생각했다.\n그중 하나가 폴더 탐색이다. 폴더 탐색은 폴더에 트리 구조로 작성되는 포스팅들을 하나 씩 탐색하는 것으로 폴더와 파일을 탐색하며 네비게이션 생성과 포스팅 변환 등의 작업을 진행한다.\n\n## 트리 탐색\n- 사실 폴더 탐색이라고 했지만 개념은 자료구조의 기초인 트리 탐색을 활용한 기능이다.\n트리 탐색에는 전위, 중위, 후위 순회등 다양한 방법이 있지만 해당 블로그에서는 전위 순회 방식을 사용하여 폴더와 파일을 탐색하며 작업을 진행한다. 전위순회는 부모 노드에서 자식 노드 방향으로 탐색을 진행하는 방식으로 구현방법 재귀 함수로 간편하고 폴더의 구조를 네비게이션 디자인을 구조화 하기에 적합하기에 선택하게 되었다.\n\n### 코드 분석\n- 마크다운으로 작성되어 있는 포스팅 폴더를 root부터 전위 순회 방식으로 탐색하며 포스팅 파일을 찾으면 작업을 시작한다.\n\n```js\nconst treeTraver = (root) => {\n    // root에 있는 폴더와 파일의 리스트\n    const node = fs.readdirSync(root)\n\n    // 폴더와 파일 리스트를 순차적으로 확인하며 폴더일 경우와 파일인 경우에 따른 기능 개발\n    node.map((v) => {\n        const isDir = fs.statSync(`${root}/${v}`).isDirectory()\n\n        if(isDir) {\n            // 폴더 인 경우 해당 폴더를 root로 또 다시 내부 아이템 분석\n            treeTraver(`${root}/${v}`)\n        } else {\n            // 파일일 경우 파일 내용 변환 및 네이게이션 작성\n            const contents = fs.readFileSync(`${root}/${v}`, 'utf8')\n\n            const naviCode = `<a href=\"url\">${v}</a>`\n        }\n    })\n\n}\n\n// 포스팅이 작성되어 있는 root 폴더의 경로\ntreeTraver('/post')\n```\n\n- 사실 코드 자체의 원리는 어렵지 않다. 본 블로그에서는 이 코드를 기반으로 파일의 내용을 변환하고 네비게이션 사이드바를 제작하는 코드를 추가하여 제작되었다.\n이 블로그를 제작할때 핵심 테마인 '마크다운으로 작성하고 폴더 구조 기반으로 웹 페이지로의 변환한다.'에 맞춰 폴더를 순회하며 모든 작업을 진행한다."},"post_16":{"title":"2. 블로그 만들기 - 마크다운 변환","file":"2. 블로그 만들기 - 마크다운 변환","index":16,"path":"_post/심심한 개발자의 취미 개발_1/간단 블로그 만들기_11/2. 블로그 만들기 - 마크다운 변환.md","fold":["1","11"],"date":20250327,"prev":13,"next":17,"content":"\n# 2. 블로그 만들기 - 마크다운 변환\n블로그 만들기 핵심 기능 2번째 마크다운 변환 관련 이다.\n정확하게 말하자면 마크다운으로 작성된 포스팅을 HTML 코드로 변환하며 HTML 페이지를 생성하는 과정을 의미한다.\n\n## 작업 내용\n작업 내용은 다음과 같이 3단계를 거치게 된다. 그중 이 포스팅에서는 두번째 과정만을 다루고 더 상세한 내용은 다음 포스팅에서 다룬다.\n\n1. 첫번째는 앞서 포스팅한 트리 탐색을 통한 네비게이션 코드의 생성이다.\n2. 두번째는 탐색을 진행하는 과정에서 얻어진 포스팅 파일의 마크다운 데이터를 HTML 코드로의 변환이다\n    - 해당 과정에서는 컨텐츠 내부에 작성되어 있는 메타 데이터를 통해 prev/next page의 이동과 페이지별 css 변경을 위한 메타 데이터가 생성된다.\n3. 마지막으로 제작된 네비게이션과 포스팅 내용을 통합하여 완성된 HTML 페이지 코드의 제작과 CSS 변경, .html 파일 생성 작업이다.\n\n## 마크다운과 HTML의 변환\n### 마크다운이란?\n우선 마크다운은 텍스트 기반의 마크업 언어로 쉬운 읽기과 쓰기를 지원하며 HTML과 대응하여 변환 가능한 문법이 특징이다.\n특수기호와 문자를 이용한 매우 간단하고 직관적인 문법을 사용하여 빠르게 컨텐츠를 작성할 수 있다.\n다만 마크다운 언어는 국제적인 표준이 없기 때문에 변환 툴이나 사이트에 따라 결과물이 달라 질 수 있으며 HTML 보다는 세부적인 부분에 대해서는 표현이 불가능 하다.\n\n### 변환 모듈\n나는 다양한 마크다운 변환 모듈를 사용해 본 결과 최종적으로 'marked' 모듈를 사용하고 있다. 대부분의 모듈이 비슷한 성능을 제공하지만 선택한 이유는 우선 사용법이 간단하고, 마크다운 문서 내부에서 HTML 코드를 지원한다는 점이다.\n마크다운은 HTML과 대응하여 변환이 가능하지만 앞서 말한것과 같이 HTML 처럼 세부적인 디자인은 어려운 부분이 많기에 마크다운 문서에서 HTML 코드를 작성하는 경우가 종종 있다.\n타 모듈에서는 HTML 태그의 '<', '>'를 특수기호로 인식해 HTML 문자 엔티티로 변환해버려 HTML 태그를 사용할 수 없었으나 'marked'에서는 정상적으로 변환이 가능하여 선택하게 되었다.\n\n### 변환 코드\n- 사실 변환 코드는 너무나 간단하다. 'fs.readFile()'함수를 이용하여 마크다운 파일의 내용을 읽어와 'marked.parse()'를 사용하여 html 코드를 생성한다.\n\n```js\nconst markdown = fs.readFileSync('index.md', 'utf8')\nconst html = marked.parse(markdown)\n```\n\n- 하지만 마크다운 만으로는 포스팅은 가능하지만 블로그의 기능을 구현하기 위해서는 다양한 이벤트와 기능적인 코드가 필요하다. 그러한 작업을 위한 메타데이터와 일부 코드의 수정이 위 코드에서 함께 이루어진다.\n\n~~~js\nlet markdown = fs.readFileSync(`${root}/${v}`, 'utf8').trim()\n\n// 마크다운에서 코드 작성 문법인 '```' 문자열의 모든 위치를 리스트화\nconst point = [...markdown.matchAll(/```/g)].map((v) => { return v.index })\n\n// 찾아낸 '```' 문자열 위치를 활용하여 내부 코드 추출\nconst tempData = markdown.substring(point[0], point[1] + 3)\n\n// JSON으로 작성된 추출한 코드 데이터를 이후 블로그 페이지 생성을 위한 메타 데이터로 활용\nconvertData['metaData'] = JSON.parse(tempData.replaceAll('```json', '').replaceAll('```', ''))\n\n// 변환된 HTML 코드에서 이미지와 같이 외부 파일을 참조하는 경우 배포/개발환경에 따른 알맞은 위치의 폴더를 참조하도록 코드 수정\nconvertData['mdFile'] = marked.parse(markdown.replace(tempData, '')).replaceAll(/(?<=\")[^\"]*(?=image)/g, `${json[process.env.NODE_ENV].url}/`)\n~~~\n\n### 개선될 변환 코드\n사실 나의 블로그를 만드는데 가능한 외부 라이브러리를 사용하는 것을 지양하고 싶다. 차후 마크다운의 변환 모듈을 직접 개발할 계획이며 위코드에서 덕지덕지 붙어 있는 'replaceAll' 코드들을 조금 유지보수가 간편한 모듈화를 이루고자 한다."},"post_17":{"file":"3. 블로그 만들기 - 리펙토링","index":17,"path":"_post/심심한 개발자의 취미 개발_1/간단 블로그 만들기_11/3. 블로그 만들기 - 리펙토링.md","fold":["1","11"],"date":20250422,"prev":16,"content":"\n# 3. 블로그 만들기 - 리펙토링\n블로그를 만들기 시작한지 한달 정도 지났다.\n평소 생각하던 디자인과 기능, 로직을 작성하고 개선하고 포스팅글을 적다보니 여러 부족하고 개선하고 싶은 부분들이 자꾸 눈에 밟혔다.\n그래서 추가적인 기능 개선을 할려고 보니 흔히 말하는 클린코드, 모듈화에 대하여 많이 부족하다고 느껴졌다. 그래서 지금까지의 기능을 포괄하도록 새로운 코드로 앞으로의 개선을 위한 리팩토링을 진행하였다.\n\n## 핵심 데이터 기준의 작동\n- 우선 리팩토링의 가장 핵심은 핵심 데이터의 존재이다.\n구 버전에서는 네비게이션, 포스팅 페이지를 제작할때마다 파일 탐색을 진행하며 파일에 작성되어 있는 데이터를 읽어 들이는 작업을 진행하였다. 이러한 방식은 로직이 간편하다는 장점이 있지만 성능상의 이슈가 우려되고 개선 작업이 추가될때마다 네비게이션과 포스팅 페이지 작성 로직을 모두 수정해야 되는 단점이 있었다.\n다양한 기능과 로직이 추가될수록 두 곳에서의 로직을 수정해야하는데 분석에 들어가는 시간이 늘어가기에 로직 수정의 필요성을 느끼게 되었다.\n- 핵심 데이터는 위와 같은 이슈를 해결하기위 최초 1회 파일 탐색을 수행하며 필요한 데이터를 모두 포함하는 JSON 기반의 데이터 트리를 제작하고 이러한 데이터를 기반으로 네비게이션과 포스팅 페이지를 제작하는 방식이다.\n기능이 추가되고 수정작업이 진행되며 필요한 데이터가 추가될시 JSON 데이터를 생성할때 추가하여 로직간의 충돌을 최소화 하게 되었다.\n\n```js\nconst recursion = (root, fold = []) => {\n    const temp = {}\n\n    // ballboy / index 파일과 공통 파일들의 관리 방안에 대하여 고민해보기\n    const post = fs.readdirSync(root).filter((v) => { return ['_Common', 'index.md'].indexOf(v) < 0 })\n\n    post.map((v) => {\n        // 최초 1회 파일 리딩\n        const isDir = fs.statSync(`${root}/${v}`).isDirectory();\n\n        if (isDir) {\n            // 디렉토리/네비게이션 제작을 위한 데이터를 포함한 json 데이터\n            const [title, index] = path.basename(v, path.extname(v)).split('_');\n\n            if (parseInt(index) !== 0) {\n                const child = recursion(`${root}/${v}`, [...fold, index]);\n                const count = Object.keys(child).reduce((a, b) => {\n                    const [type, index] = b.split('_');\n                    return a + (type === 'dir' ? child[b].count : (parseInt(index) === 0 ? 0 : 1));\n                }, 0);\n\n                const item = {\n                    title,\n                    file: '',\n                    index: parseInt(index),\n                    count,\n                    // 디렉토리 내부 아이템은 children이라는 데이터 내부에 저장된다.\n                    children: { ...child }\n                };\n\n                temp[`dir_${index}`] = item;\n            }\n        } else {\n            // 포스팅 페이지 제작을 위한 데이터를 포함한 json 데이터\n            const mdFile = matter(fs.readFileSync(`${root}/${v}`, 'utf8').trim());\n            const title = mdFile.data?.title;\n            const index = mdFile.data?.index || 0;\n\n            if (parseInt(index) !== 0) {\n                const item = {\n                    title,\n                    file: path.basename(v, path.extname(v)),\n                    index: parseInt(index),\n                    path: `${root}/${v}`,\n                    fold,\n                    date: mdFile.data?.date || '99999999',\n                    ...mdFile.data,\n                    content: mdFile.content\n                };\n\n                temp[`post_${index}`] = item;\n                utils.contents.push(item);\n            }\n        }\n\n\n    })\n\n    return temp\n}\n```\n\n## 레이아웃 세분화\n- 기존 하나의 텍스트 데이터를 기반으로 데이터만 추가하여 포스팅 페이지 html 코드를 제작했지만 개선된 버전에서는 포스팅 페이지 html 코드의 헤더와 profile, navi, content, prev, next 등 코드를 세분화 하여 최종적으로 하나로 합치도록 수정이 되었다.\n그 결과 디자인 개선 작업이나 기능 추가 작업에서도 좀 더 직관적인 코드 분석과 개선 작업이 가능해졌다.\n\n~~~js\nconst assets = (param) => {\n    const { assetsUrl, index, fold } = param\n\n    const html = `\n<link rel='stylesheet' href='${assetsUrl}/markdown.css'>\n<link rel='stylesheet' href='${assetsUrl}/skin.css'>\n\n<style>\n    #p-${index} {\n        color: rgb(76, 193, 237) !important;\n    }\n</style>\n<script id='data' type='application/json'>\n{\n    'fold': ${JSON.stringify(fold)}\n}\n</script>\n\n<script src='${assetsUrl}/skin.js'></script>\n    `\n\n    return html\n}\n\nconst prev = (param) => {\n    const { url, prev } = param\n\n    const html = `\n<a href='${url}/post/${prev}.html' class='prev post'>\n    <img src='${url}/assets/img/prev.svg' alt='' srcset=''>\n</a>\n    `\n\n    return html\n}\nconst next = (param) => {\n    const { url, next } = param\n\n    const html = `\n<a href='${url}/post/${next}.html' class='next post'>\n    <img src='${url}/assets/img/next.svg' alt='' srcset=''>\n</a>\n    `\n\n    return html\n}\n~~~\n\n## 포스팅 파일 데이터 관리 방법 - gray-matter\n- 기존 포스팅 파일을 위한 메타 데이터는 파일 이름 타이틀과 index 번호를 작성하고 좀더 디테일한 데이터는 파일 내용에 json 형식으로 작성하였고 파일 변환 과정에서 json 형식을 추출하고 삭제하는 방식을 사용하였다. 이러한 방법은 데이터 추가에 어려움을 야기하고 데이터 처리의 난이도를 높이게 되었다.\n다양한 방법을 찾아보다가 gray-matter 라이브러리를 찾아 사용하게 되어 데이터 관리 방안을 개선할 수 있었다."},"post_0":{"file":"9. 블로그 만들기 - 마크다운 변환 모듈 개발","index":0,"path":"_post/심심한 개발자의 취미 개발_1/간단 블로그 만들기_11/9. 블로그 만들기 - 마크다운 변환 모듈 개발.md","fold":["1","11"],"date":20250404,"content":""},"post_1":{"title":"블로그 개발, 배포 일지","file":"블로그 개발, 배포 일지","index":1,"path":"_post/심심한 개발자의 취미 개발_1/간단 블로그 만들기_11/블로그 개발, 배포 일지.md","fold":["1","11"],"date":20250320,"next":10,"content":"\n# 개발 / 배포 일지\n- 2025-03-14\n    - 개발 시작\n    - 기본 디자인 Mockup.html 파일 작성\n    - skin.css, skin.js 파일 생성\n\n- 2025-03-17\n    - 네비게이터 기능 개발 \n    - 마크다운 변환 기능 개발 \n\n- 2025-03-18\n    - 블로그의 기본 기능 및 형태 개발 완료\n    - 포스팅 작성 시작\n\n- 2025-03-20 \n    - 개발 환경 개선 작업 (css/js 파일 배포 환경과 배포 환경에서의 링크 주소 연결)\n    - 블로그 만들기 글 작성 시작\n    - 작성된 글 / 작성중인 글 / 미 배포 글 구분 및 글 리스트 정리 내용 파일화\n    - 모바일 반응형 디자인 1차 적용\n        - 화면 사이즈 적용\n        - navi open/close 기능 개발\n    - 네비게이터 디자인 수정\n\n- 2025-03-21\n    - 사이드바 css 일부 수정\n\n- 2025-03-23 \n    - 마크다운 변환 라이브러리 변경\n        - mardown-it -> marked\n\n- 2025-03-24 \n    - 디렉토리 넘버링 방법 변경\n\n- 2025-03-27 \n    - 포스팅 파일 네이밍 변경\n    - prev/next 이동 기능 생성 \n        - 페이지 크기에 따른 이동 버튼 생성에 대한 고민 필요\n\n- 2025-03-29\n    - 개발/테스트 환경 디렉토리 생성 코드 수정\n        - 개발 테스트를 위한 임시(미 배포용) 디렉토리 생성 기능 - 넘버링 '0'\n\n- 2025-03-30 \n    - 개발/테스트 환경 디렉토리 생성 코드 수정\n        - 넘버링이 아예 없는 경우 처리\n    - 카테고리별 포스팅 개수 표시    \n\n- 2025-04-03 \n    - 카테고리 Index 페이지 생성 및 디자인 작업\n\n- 2025-04-04 \n    - 기능 고도화와 변환 기능 라이브러리화 진행을 위한 사전 리팩토링 작업 기획\n        - 트리 탐색의 최소화 \n        - 반복 작업의 최소화\n\n- 2025-04-15\n    - 빌드 코드 version.2 개발 작업 진행\n\n- 2025-04-19 \n    - 빌드 코드 version.2 개발 작업(리팩토링) 진행\n        - 대부분 기능 작업 완료\n        - prev, next 데이터 관리 방법 고민 중\n            - gray-matter 라이브러리에 대하여 조그만 더 빨리 알았더라면...\n        - index 페이지 등 공통 페이지 관리 방법 고민 중\n        - 이미지 URL 변환 코드 수정 작업\n\n- 2025-04-21\n    - 데이터 정렬 로직 수정\n    - 포스팅 리스트 작성 파일 생성 로직 개발\n\n- 2025-04-24 \n    - 이미지 경로 변경 로직 수정\n    - index 페이지 생성 및 디자인 변경\n\n- 먼 미래\n    - 백엔드와 함께 클라우드상 개인 사이트 배포"}}},"dir_12":{"title":"개발 팁","file":"","index":12,"count":2,"children":{"post_15":{"title":"docker 기본 정리","file":"docker 기본 정리","index":15,"path":"_post/심심한 개발자의 취미 개발_1/개발 팁_12/docker 기본 정리.md","fold":["1","12"],"date":20250328,"prev":null,"next":null,"content":"\n- 도커는 컨테이너라는 경량 단위로 애플리케이션을 실행하는 기능을 제공하는 플랫폼이다.\n- 컨테이너는 독립적인 호스트명, IP주소, 디스크 볼륨을 갖는다.\n- 도커의 핵심은 격리(isolation)와 밀집(density)\n\t- 밀집이란 컴퓨터에 CPU와 메모리가 허용하는 한 되도록 많은 수의 애플리케이션을 실행하는 것을 의미한다.\n\n- 컨테이너는 내부의 애플리케이션이 실행 중이어야 컨테이너의 상태도 실행 중이 된다\n- 컨테이너가 종료돼도 컨테이너는 사라지지 않는다.\n- 설치된 도커는 호스트 컴퓨터의 네트워크 계층을 감시하며 호스트 컴퓨터에서 들나드는 네트워크 트레픽을 모두 도커가 가로채서 그중 필요한 것을 컨테이너에 전달하게 된다.\n\n\n## Docker 기본 명령어\n### 이미지 관련 명령어\n- 이미지 검색\n```bash\ndocker search [image name]\n```\n\n- 이미지 다운\n```bash\n# version에 latest를 붙이면 최신버전으로 다운\ndocer pull [image name]:[version]\n```\n\n- 이미지 삭제\n```bash\ndocker rmi [image id]\n\n# -f : 컨테이너와 이미지 함께 삭제\ndocker rmi -f [image id]\n```\n- 이미지 목록 보기\n```bash\ndocker image ls\ndocker images\n```\n\n### 컨테이너 관련 명령어\n- 컨테이너 목록 보기\n```bash\ndocker ps\ndocker container ls\n\n# 모든 컨테이너 목록 (작동 및 종료 상태의 모든 컨테이너)\ndocker ps -a\n```\n\n- 컨테이너 생성\n```bash\ndocker create [OPTIONS] IMAGE [COMMAND] [ARG...]\n```\n \n- 컨테이너 실행\n```bash\ndocker start [container id | container name]\n```\n\n- 컨테이너 실행\n```bash\ndocker run [OPTIONS] IMAGE [COMMAND] [ARG...]\n```\n\n> docker create / start / run 의 차이점\n> - create : docker image를 기반으로 컨테이너 생성\n> - start : 이미 생성되어 있는 컨테이너를 실행\n> - run : create + start 기능으로 컨테이너가 생성되어 있다면 실행 없다면 이미지 기반으로 생성 후 실행, 이미지에도 없다면 docker hub등에서 pull 받은 후 실행\n\n\n- 컨테이너 재시작\n```bash\ndocker restart [container id | container name]\n```\n\n- 컨테이너 정지\n```bash\ndocker stop [container id | container name]\n```\n\n- 컨테이너 삭제\n```bash\ndocker rm [OPTIONS] CONTAINER [CONTAINER...]\n\n# 모든 컨테이너 삭제\ndocker rm docker ps -a -q\n\n# 컨테이너 강제 삭제 (실행중인 컨테이너 포함)\ndocker rm -f CONTAINER\n\n# 모든 컨테이너 강제 삭제 \ndocker rm -f $(docker ps -a -q)\n```\n\n- 컨테이너 로그\n```bash\ndocker logs [OPTIONS] CONTAINER\n```\n\n- 컨테이너 상세 정보\n```bash\ndocker inspect [OPTIONS] NAME|ID [NAME|ID...]\n```\n\n- 컨테이너 실시간 리소스\n```bash\ndocker stats [OPIONS] [CONTAINER...]\n```\n\n## Docker run 기본 옵션\n- Docker run 커맨드 기본 포멧\n```bash\ndocker run (<options>) <imageId> (<command>) (<parameter>)\n```\n\n- `-d` option\n\t- `-d` 옵션을 사용하면 컨테이너가 detached 모드에서 실행되며, 실행 결과로 컨테이너 ID만을 출력합니다.\n\t- `-d` 옵션없이 실행했다면 해당 터미널에서 `command c` 를 눌러서 빠져 나오는 순간 해당 컨테이너는 종료 됩니다.\n```bash\ndocker run -d python:3.8-alpine\n```\n\n- `—-interactive` option\n\t- 컨테이너 접속 상태 유지 옵션\n\n- `—-tty` option\n\t- 터미널 세션을 통한 컨테이너 조작 옵션\n```bash\ndocker run —interaction —tty [image]:[tag]\n```\n\n\n- `-it` option\n\t- `-i`옵션과 `-t`옵션은 함께 쓰이면 컨테이너를 종료하지 않은체로, 터미널의 입력을 계속해서 컨테이너로 전달하기 위해서 사용합니다.\n```bash\ndocker run -it python:3.8-alpine\n\ndocker run -it python:3.8-alpine /bin/sh\n```\n\n- `--name` option\n\t- `—-name` 옵션을 사용하여 컨테이너에 이름을 부여할수 있습니다. \n\t- 부여된 이름으로 컨테이너를 식별 할 수 있습니다.\n```bash\ndocker run -d —-name my-server python:3.8-alpine python -m http.server\ndocker ps\ndocker kill my-server\ndocker rm my-server\n```\n\n- `-e` option\n\t- `-e` 옵션은 docker container의 환경변수를 설정하기 위해서 사용합니다.\n\t- `-e` 옵션을 사용하면 Dockerfile의 ENV 설정도 덮어써지게 됩니다.\n```bash\ndocker run -e FOO=bar python:3.8-alpine env\n```\n\n- `-p` option\n\t- `-p` 옵션은 호스트와 컨테이너간의 포트(port) 배포 / 바인드 (bind)를 위해서 사용됩니다.\n\t- 호스트 컴퓨터에서 컨테이너에서 리스닝 하고 있는 포트로 접속할 수 있도록 설정해줍니다.\n```bash\n# 컨테이너 내부에서 8000포트로 리스닝 하고 있는 HTTP서버를 호스트 컴퓨터에서 80 포트로 접속할 수 있도록 설정\ndocker run -d -p 80:8000 python:3.8-alpine python -m http.server\n```\n\n- `-v` option\n\t- `-v` 옵션은 호스트와 컨테이너 간의 볼륨 설정을 위해서 사용됩니다.\n\t- 호스트 컴퓨터의 파일 시스템의 특정 경로를 컨테이너의 파일 시스템의 특정 경로로 마운트 합니다.\n```bash\necho Hi > test.txt\ndocker run -v `pwd`:etc python:3.8-alpine cat /etc/test.txt\n```\n\n- `-w` option\n\t- `-w` 옵션은 Dockerfile의 WORKDIR 설정을 덮어쓰기 위해 사용됩니다.\n```bash\ndocker run -w /etc python:3.8-alpine pwd\n```\n\n- `—-entrypoint` option\n\t- `—-entrypoint` 옵션은 Dockerfile의 ENTRYPOINT 설정을 덮어쓰기 위해서 사용합니다.\n```bash\ndocker run —-entrypoint python python:3.8-alpine —-version\n```\n\n- `—-rm` option\n\t- `—-rm` 옵션은 컨테이너가 종료될 때 컨테이너와 관련된 리소스(파일 시스템, 볼륨) 까지 깨끗이 제거합니다.\n```bash\ndocker run —-rm -it wernight/funbox nyancat\n```"},"post_3":{"title":"vim 에디터 정리","file":"vim 에디터 정리","index":3,"path":"_post/심심한 개발자의 취미 개발_1/개발 팁_12/vim 에디터 정리.md","fold":["1","12"],"date":20250319,"content":"# vi/vim 에디터 사용법/단축키 정리\n요즘은 개발 업무를 진행하다 보면 정말 다양한 취향에 맞는 수많은 에디터 들이 많다\nnode.js를 베이스로 개발을 진행하는 필자는 당연하게도 vscode를 메인으로 사용하고 있다.\n하지만 docker 환경과 서버단의 작업이 늘어나면서 터미널에서의 작업이 늘어나고 당연하게도 vi 에디터를 사용하는 경우가 늘어나고 있다.\nvi를 사용하는데는 큰 어려움은 없지만 이번 기회에 학부때 정리해두었던 내용을 다시 한번 정리해 보고자 한다.\n\n## vi/vim\nvi/vim 에디터는 unix 계열의 운영체제에서 주로 쓰이는 매우 유서가 깊은 에디터이다. 태생이 CLI 환경이다 보니 마우스와 키보드 방향키가 없어도 아주 강력한 문서 편집 기능을 제공한다.\nvim은 이러한 vi를 기반으로 GUI 환경과 다양한 기능들이 추가되어 개량된 버전으로 대부분의 터미널에서 'vi'를 실행시키더라도 'vim'이 실행된다.\n이하부터는 vi와 vim을 구분하지 않고 vi라 지칭한다.\n\n## 사용법\nvi에는 3가지의 모드가 존재한다.\n\n- 명령 / 이동 / 편집 모드\n    - 입력 커서의 이동과 내용의 수정, 삭제, 복사 등 문서 작업을 위한 모드\n- 입력 모드\n    - 실제 타이핑을 통한 내용 입력을 위한 모드\n- ex / 실행 모드\n    - 내용 검색, 변환 등의 기능 수행 모드\n\n각 모드는 ESC 키와 키 문자를 통해 서로간의 변환이 이루어 진다.\n기본은 명령모드로 시작하며 특별한 표시는 없다\n명령모드에서 'a', 'i', 'o' 등의 키를 입력하면 입력모드로 변경이 이루어지며 터미널 하단에 '-- INSERT --' 표시가 나타난다.\n다시 ESC 키를 누르면 명령모드로 변경되고 실행 모드 명령어의 시작 문자인 ':' 또는 '/'를 입력하면 실행 모드로 변경된다.\n\n## 모드별 명령어 (※ 대소문자 구분)\n### 명령 모드\n- 단어 단위로 이동\n    - W, w : 다음 단어의 처음으로 이동\n    - E, e : 단어의 끝으로 이동\n    - B, b : 단어의 처음으로 이동\n\n- 행 단위로 이동\n    - *0(숫자)* : 행의 처음으로 이동\n    - *$* : 행의 마지막으로 이동\n\n- 문서 단위로 이동\n    - *G* : 문서의 마지막으로 이동\n    - *gg* : 문서의 처음으로 이동\n    - ctrl + f : 한 페이지 앞으로 이동\n    - ctrl + b : 한 페이지 뒤로 이동\n    - shift + h : 화면의 처음으로 이동\n    - shift + m : 화면의 중앙으로 이동\n    - shift + l : 화면의 끝으로 이동\n\n- 복사 / 삭제\n    - x : 커서가 위치하는 문자 삭제\n    - X : 커서가 있는 앞 문자 삭제 \n    - *dd* : 커서가 위치하는 행 삭제 (한줄 삭제)\n    - *⍺dd* : 커서가 위치하는 행 포함 아래 ⍺줄 삭제\n    - *yy* : 커서가 위치하는 행 복사 (한줄 복사)\n    - *⍺yy* : 커서가 위치하는 행 포함 아래 ⍺줄 복사\n    - *p* : 커서가 위치하는 행 아래에 복사한 내용 붙여 넣기\n    - *P* : 커서가 위치하는 행 위에 복한 내용 붙여 넣기\n\n- dd / yy 의 활용 (커서 위치 기준)\n    - dw, yw : 다음 단어의 처음까지 삭제 / 복사\n    - de, ye : 단어의 끝까지 삭제 / 복사\n    - db, yb : 단어의 처음까지 삭제 / 복사\n    - d0, y0 : 행의 처음까지 삭제 / 복사\n    - d$ / y$ : 행의 마지막까지 삭제 / 복사\n    - dG, yG : 문서의 마지막까지 삭제 / 복사\n    - dgg, ygg : 문서의 처음까지 삭제 / 복사\n\n### 입력 모드\n- *i* : 현재 위치에서 입력 모드로 전환\n- I : 행의 제일 처음에서 입력 모드로 전환 (0 + i)\n- *a* : 현재 위치에서 우측으로 한 칸 이동 후 입력 모드로 변경\n- A : 행의 제일 마지막에서 입력 모드로 변경 ($ + i)\n- *o* : 현재 커서 위치의 한 줄 아래에 새로운 행을 추가하고 입력모드로 변경\n- O : 현재 커서 위치의 한 줄 위에 새로운 행을 추가하고 입력모드로 변경\n- s : 현재 문자를 지우고 입력 모드로 변경\n- S : 현재 행의 모든 문자를 지우고 입력 모드로 변경 (dd + i)\n\n### 실행 / EX 모드\n- *:se nu* : 라인 번호 활성 (:set number)\n- :se nonu : 라인 번호 비활성 (:set nonumber)\n- :[n] : n번째 라인으로 이동\n- */Pattern* : Pattern 검색\n    - n : 아래 방향으로 계속 검색\n    - N : 윗 방향으로 계속 검색\n- *:[범위]s/[Old]/[New]/[option]* : 범위 내의 Old를 New로 치환\n    - 범위\n        - % : 문서 전체\n        - n : n번째 라인에서\n        - n,m : n번째 라인에서 m번째 라인까지 \n        - -n,+m : 커서위 n번째 라인에서 커서 밑 m번째 라인까지\n    - 옵션\n        - g : 적용 범위내 모두 변경\n    - 예시\n        - :s/old/new : 현재 라인에서 첫번째 old만 new로 변경\n        - :s/old/new/g : 현재 라인의 모든 old를 new로 변경\n        - :10s/old/new : 10번 라인에서 첫번째 old를 new로 변경\n        - :10,15s/old/new/g : 10번에서 15번까지의 라인에서 모든 old를 new로 변경\n        - :-3,+4s/old/new/g : 커서 기준 위로 3번째, 아래로 4번째 라인까지의 모든 old를 new로 변경\n        - :%s/old/new/g : 문서 전체에서 old를 new로 변경\n\n- 화면 분할\n    - *:[n]sp [파일이름]* : 수평 나누기\n    - :[n]vs [파일이름] : 수직 나누기\n        - [n] : 라인 수\n        - ctrl + wn : 현재 화면을 수평으로 나누기\n        - ctrl + wv : 현재 화면을 수직으로 나누기\n        - ctrl + ww : 창간 이동\n\n- 파일 관련 명령어\n    - *:q* : 나가기\n    - *:q!* : 강제 종료\n    - *:w* : 저장\n    - *:wq* : 저장하고 나가기\n    - :e [목적파일] : 현재 창을 닫고 파일 열기/생성\n    - :e! [목적파일] : 현재 창을 강제로 닫고 파일 열기/생성\n    - :enew : 현재 창을 닫고 빈 새 문서를 생성\n    - :f : 현재 커서 위치 정보\n    - :w >> [목적파일] : 현재 편집중인 파일을 목적 파일 끝에 추가\n    - :w [파일명] : 다른 이름으로 저장\n    - :[n]r[파일명] : 파일 이름의 내용을 현재 편집중인 파일의 n라인부터 삽입\n    - :[n]r![command] : command 실행 결과를 파일의 n라인부터 삽입\n    - :.![command] : command 실행 결과를 커서의 현재 라인을 지우고 삽입\n\n\n> 해당 문서는 모두 vi 에디터로 작성되었습니다."}}}}},"dir_3":{"title":"의식의 흐름대로","file":"","index":3,"count":0,"children":{"post_0":{"title":"사람들은 왜 디즈니의 PC주의를 싫어 하는가","file":"사람들은 왜 디즈니의 PC 주의를 싫어하는가","index":0,"path":"_post/의식의 흐름대로_3/사람들은 왜 디즈니의 PC 주의를 싫어하는가.md","fold":["3"],"date":99999999,"prev":0,"next":0,"content":"\n- 아이언하트\n- 캡틴 마블\n- 인어공주/백설공주\n- 마일스 모랄레스\n\n### 왜 사람들은 디즈니/마블의 PC주의를 부정적인 시각으로 바라 보는가?\n0. 사람들은 영화를 보며 시각적, 음향적, 팬심 등등을 기반으로 다양한 감정을 느낀다.\n특히, 단순 오락 영화를 넘어 흔히 대작, 명작 이라고 하는 영화들에서는 영화 스토리, 내용적인 측면의 완성도가 중요시 된다. 그러한 맥락에서 디즈니의 PC주의적 영화들은 정당한 값을 지불하고 명작을 즐기고자한 영화 팬들의 충분한 즐거움을 주지 못한것을 넘어 오히려 부정적인 감정을 부여하는 결과를 이끌어 냈다.\n\n1. 부족한 서사\n    - 마블의 히어로 시리즈가 명작으로 평가 받는 이유는 화려한 액션신, 음향 효과, 다양한 히어로의 출현으로 인한 팬적인 즐거움도 있었겠지만 2008년 시작된 아이언 맨을 시작으로 주인공들의 탄생과 그들이 어떻게 능력을 얻었고 왜 개인적인 이득을 위한 악당이 아닌 목숨을 건 영웅이 되었으며 그 과정에서 느끼는 감정과 어려움, 인간관계 등을 어떻게 극복해 나갔는지에 대한 섬세하고 감정적인 내용이 포함되어 있었다.\n    그러한 과정을 영화를 통해 시청하며 사람들은 본인이 처한 상황에 대입하거나 무조건적인 권선징악이 아닌 선이 악을 이기는게 필연적이 아니지만 어려움을 극복해 나가며 선을 이끌어 내는 영화의 내용에 내적 즐거움을 느꼈을 것이다.\n    하지만 최근 개봉하는 마블의 영화들에서는 이러한 장기적이고 깊은 감정선을 대폭 줄이며 시각적인 액션 영화를 만들어 캐릭터 구축에만 급급한 모양세를 가지고 있다.\n    대표적으로 블랙 펜서의 아이언 하트와 2대 블랙 펜서에서 잘 드러나고 있다."}}},"dir_2":{"title":"자취생 밥 만들어 먹기","file":"","index":2,"count":11,"children":{"dir_21":{"title":"5첩 반상을 위한 밑반찬","file":"","index":21,"count":3,"children":{"post_5":{"title":"겉절이 김치","file":"겉절이 김치","index":5,"path":"_post/자취생 밥 만들어 먹기_2/5첩 반상을 위한 밑반찬_21/겉절이 김치.md","fold":["2","21"],"date":20250319,"content":"\n# 겉절이 김치 만들기\n\n```\n역시 한국인은 김치 없이는 안된다.\n항상 고향의 어무이한테 김치를 얻어 먹었다. 하지만 역시 어머니의 마음이란...\n맛있는 김치를 정말 많이 보내주시는데 직장인이 집에서 밥을 얼마나 자주 먹겠나...\n금방 김치는 쉬어 버리고 반찬으로 먹기 힘들어 진다.\n그래서 아들 집에 놀러오신 엄마를 붙잡고 김장...은 아니고 겉절이 김치를 배워 보았다.\n역시 한국인은 김치 없이는 안된다.\n```\n\n![이미지 준비중](<file:///Users/ballboy/workspace/project/static-site-generator/ver-node2/_dist/assets/img/이미지 준비중.png>)\n\n\n### 난이도 ✭✭✭\n> 역시 한국인은 김치 없이는 안된다.\n\n\n## 재료\n||재료명|용량(개수)|비고|양념(조미료)|용량(개수)|비고|\n|:-:|:--|:--|:--|:--|:--|:--|\n|1|알배추|1통||고추가루|4sp||\n|2|다진 마늘|2sp||액젓|3sp||\n|3|쪽파 or 대파|적당량||생강청|0.5sp||\n|4||||매실청|0.5sp||\n|5||||설탕|0.5sp||\n|6||||굵은 소금|한 주먹||\n\n\n## 레시피\n1. 알배추의 잎을 따서 먹기 적당한 크기로 자른다.\n\n1. 썰은 배추 잎을 물에 헹구고 굵은 소금 1주먹과 깨끗한 물을 넣고 30분간 배춧잎을 절인다.\n    - 소금음 물에 푸었을때 오우ㅆ... 할 정도?\n    - 15분쯤에 한번 뒤집어 골고루 절일 수 있도록 한다.\n\n1. 쪽파나 대파를 3 ~ 4cm 정도로 채썰어 준다,\n\n1. 30분 후 배추가 절여졌으면 물을 버리고 채썬 파와 아래 양념을 모두 넣고 버무린다.\n    - 고추가루, 액젓, 생강청, 매실청, 설탕\n\n1. 버무린 다음 색과 간에 따라 고춧가루와 액젓을 넣어 간을 맞춘다. \n\n1. 다 버무린 다음 김치는 통에 눌어 담는다.\n\n1. 맛잇게 먹는다.\n\n\n~~~\n>> 자취생 평가 <<\n\n겉절이 인데 익으니가 그냥 김치랑 똑같아 지더라\n~~~"},"post_7":{"title":"고추다대기","file":"고추다대기","index":7,"path":"_post/자취생 밥 만들어 먹기_2/5첩 반상을 위한 밑반찬_21/고추다대기.md","fold":["2","21"],"date":20250320,"content":"\n# 고추 다대기 만들기\n\n```\n가끔은 요리하기가 너무 귀찮을 때가 있다.\n그렇다고 맨밥에 간장만 찍어 먹어도 맛있지만 쫌 그렇지 않은가...\n그래서 밑반찬에서도 가장 밑반찬이지만 임팩트는 어마어마한 매콤한 고추다대기를 만들어 보았다.\n무려 소고기가 들어 가지만 심심하면 마트 구경을 가다보니 가끔 50~60%를 할인하는걸 만날 수 있었다.\n```\n\n![이미지 준비중](<file:///Users/ballboy/workspace/project/static-site-generator/ver-node2/_dist/assets/img/이미지 준비중.png>)\n\n### 난이도 ✭ ✭ ✭\n> 흰밥에 쓱~ 쓱~ 고추 다대기\n\n\n## 재료 (재료 및 조미료)\n||재료명|용량(개수)|비고|양념(조미료)|용량(개수)|비고|\n|:-:|:--|:--|:--|:--|:--|:--|\n|1|청양고추|마트 한봉(대략 15개)||양조간장|2sp||\n|2|풋고추|마트 한봉(대략 15개)||맛술|2sp||\n|3|양파|반개||생강청|1sp|물엿 대체 가능|\n|4|다진마늘|1sp||액젓|2sp|육수 한알 대체 가능|\n|5|다진 소고기|150g||참기름/통깨|||\n|0|||||||\n\n\n## 레시피\n1.  청양고추, 풋고추, 양파를 모두 다져서 준비한다.\n\n1. 식용유를 뿌린 펜에 다진 양파와 다진 마늘을 중불에서 볶아 준다.\n\n1. 양파와 마늘이 익기 시작하면 다진 소고기와 아래 양념을 넣고 계속 볶아준다.\n    - 진간장, 맛술, 생강청\n\n1. 고기에 붉은색이 사라지면 다진 청양고추와 풋고추를 넣고 계속 볶아준다.\n\n1. 볶다가 액젓을 2sp을 넣어준다.\n    - 액젓이 없으면 육수 한알을 잘게 부셔서 넣어준다 \n    - 농도가 너무 되직하거나 묽은 다대기를 원할 경우 물을 취향에 따라 100ml 정도 넣어준다.\n\n1. 적당한 농도가 되면 참기름과 통깨를 넣고 마무리 한다.\n\n1. 맛잇게 먹는다.\n\n\n~~~\n>> 자취생 평가 <<\n\n만드는 과정이 쫌 귀찮지만 만들어 두면 듬직하다.\n라면에 한 숫가락 넣으면 스트레스 풀이용으로 제격이다.\n~~~\n\n## 참고 자료/영상\n- []()\n\n## 추가 내용\n- 2025-03-20\n    - 오래 볶아서 고추가 물러진게 더 맛있었던거 같다."},"post_11":{"title":"김짱아치","file":"김 짱아찌","index":11,"path":"_post/자취생 밥 만들어 먹기_2/5첩 반상을 위한 밑반찬_21/김 짱아찌.md","fold":["2","21"],"date":20250322,"content":"\n# 김 짱아찌 만들기\n\n```\n갑자기 언제적 먹었는지 기억도 잘 안나는 김으로 만든 어무이 요리가 생각이 났다\n레시피를 찾아보는데 김 볶음? 김 무침? 김 자반?...\n다음 날 어무이 한테 연락했다. 김 짱아찌 인데 원래는 네모 반듯하게 만들지만 그때 김을 잘 못 사서 죽처럼 되었었다고 한다.\n난 그게 더 맛있던데...?\n```\n\n![이미지 준비중](<file:///Users/ballboy/workspace/project/static-site-generator/ver-node2/_dist/assets/img/이미지 준비중.png>)\n\n### 난이도 ✭\n> 순식간에 만드는 밑반찬 김 짱아찌\n\n\n## 재료 준비\n### 재료\n||재료|용량(개수)|비고|\n|:-:|:-:|:--|:--|\n|1|구운김|10장||\n|2|청양고추|1~2개||\n|3|대파or쪽파|적당량||\n\n### 양념(조미료)\n||양념(조미료)|용량(개수)|비고|\n|:-:|:-:|:--|:--|\n|1|양조간장|100ml||\n|2|설탕|1큰술||\n|3|맛술|2큰술||\n|4|물엿|3큰술||\n|5|통깨|1큰술||\n\n\n## 레시피\n1. 양조간장, 물엿, 맛술, 설탕을 잘 섞어 약 3분정도 끓여준다.\n    - 매콤한 맛을 원한다면 취향에 따라 청양고추를 1~2개 정도를 다져서 넣고 함께 끓인다.\n\n1. 양념이 끓으면 불을 끄고 통깨를 넣어 준다.\n\n1. 구운 김을 비닐 봉투에 넣고 잘개 잘개 부셔준다.\n    - 도시락 김 크기로 잘러서 사용해도 된다.\n\n1. 부수거나 자른 구운김 일부를 용게 담고 끓인 양념을 조금 부어준다.\n\n1. 그 위에 다진 대파나 쪽파를 조금 뿌려준다.\n\n1. 구운김이 모두 사용될 때 까지 반복한다.\n    - 취향에 따라 양념의 양을 줄이거나 늘린다.\n\n1. 맛잇게 먹는다.\n\n\n~~~\n>> 자취생 평가 <<\n\n고추 다대기와 번갈아 먹으니 예술이다.\n~~~"}}},"dir_22":{"title":"난 밥먹을때 국이 필수","file":"","index":22,"count":3,"children":{"post_9":{"title":"계란국","file":"계란국","index":9,"path":"_post/자취생 밥 만들어 먹기_2/난 밥먹을때 국이 필수_22/계란국.md","fold":["2","22"],"date":20250318,"content":"\n# 계란국 만들기\n\n```\n어제 저녁을 조금 기름지게 먹어서 그런가 오늘 아침은 다른 것보다 따뜻한 국물을 먹고 싶었다.\n그래서 어떤 국을 만들까 생각하다 간단한 재료로 간편한게 만들 수 있는 계란국을 만들어 먹기로 하였다.\n물에 계란만 풀어도 되지만 간단히 재료를 추가하여 든든한 아침 국으로 만들어 보았다.\n```\n\n![이미지 준비중](<file:///Users/ballboy/workspace/project/static-site-generator/ver-node2/_dist/assets/img/이미지 준비중.png>)\n\n> 난이도 ✭\n> - 속풀이로 후추를 후추후추...\n\n\n\n## 재료\n||재료명|용량(개수)|비고|양념(조미료)|용량(개수)|비고|\n|:-:|:--|:--|:--|:--|:--|:--|\n|1|계란|2~3개||치킨스톡|1블럭(500ml용량)|국간장 또는 육수 한알로 대체 가능|\n|2|대파|조금||미림|1sp|필수 아님|\n|3|페퍼론치노|3~5개|필수 아님|후추|||\n|4||||참기름|||\n\n\n\n## 레시피\n1. 믹싱볼에 계란과 미림, 물(50ml)을 넣고 잘 풀어 준다.\n    - 계란에 팽이버섯이나 크레미와 같이 취향껏 재료를 넣어도 좋다.\n\n2. 냄비에 물 500ml와 함께 치킨스톡을 넣고 끓이다.\n    - 매콤한 맛을 원한다면 페퍼론치노를 넣고 함께 끓인다.\n\n3. 국물이 팔팔 끓으면 국물을 천천이 저으며 풀어 논 계란을 조심히 부어준다.\n\n4. 마지막으로 대파와 후추를 뿌리고 참기름을 조금 넣어 준다.\n\n5. 맛잇게 먹는다.\n\n\n~~~\n>> 자취생 평가 <<\n\n간단히 따뜻한 국물을 원할 때 픽!\n~~~"},"post_8":{"title":"국물 두루치기","file":"국물 두루치기","index":8,"path":"_post/자취생 밥 만들어 먹기_2/난 밥먹을때 국이 필수_22/국물 두루치기.md","fold":["2","22"],"date":20250321,"content":"\n# 국물 두루치기 만들기\n\n```\n환절기라 감기에 걸린거 같다.\n목이 칼칼하고 기침과 제체기가 계속 나온다.\n뜨겁고 얼큰한 국물과 몸보신을 위한 고기가 먹고 싶다.\n그럴 땐 국물 두루치기지\n```\n\n![이미지 준비중](<file:///Users/ballboy/workspace/project/static-site-generator/ver-node2/_dist/assets/img/이미지 준비중.png>)\n\n### 난이도 ✭✭✭\n> 감기가 달아 나는 얼큰한 국물 두루치기\n\n\n## 재료\n||재료명|용량(개수)|비고|양념(조미료)|용량(개수)|비고|\n|:-:|:--|:--|:--|:--|:--|:--|\n|0|돼지고기|150g||고추장|2sp||\n|0|양파|1/4개||고추가루|1sp||\n|0|대파|적당히||진간장|1sp||\n|0|청양고추|1~2개||설탕|1sp||\n|0|다진마늘|1sp||맛술|1sp||\n|0||||참기름|1sp||\n|0||||후추|0.2sp||\n\n\n## 레시피\n1. 고추장 2sp, 고추가루 1sp, 진간장 1sp, 설탕 1sp, 맛술 1sp, 참기름 1sp, 후추 조금을 모두 섞어 양념장을 만든다.\n\n1. 양파는 채썰고 대파와 고추는 적당한 크기로 썰어 준비한다.\n\n1. 돼지고기와 다진 마늘을 냄비에서 중불로 볶아 준다. \n\n1. 돼지고기가 익기 시작하면 양파와 고추, 양념장을 넣고 물 200ml를 부어준 후 강불로 끓인다.\n    - 이때 적당히 익은 김치를 함께 넣어주면 김치 두루치기가 된다\n\n1. 국물이 적당히 줄어 들면 참기름 조금과 대파 초록 부분을 넣고 마무리 한다.\n\n1. 맛잇게 먹는다.\n\n\n~~~\n>> 자취생 평가 <<\n\n생각보다 시중의 국물 두루치기 수준의 맛이 난다.\n~~~"},"post_2":{"title":"미역국","file":"미역국","index":2,"path":"_post/자취생 밥 만들어 먹기_2/난 밥먹을때 국이 필수_22/미역국.md","fold":["2","22"],"date":20250318,"content":"\n# 미역국 만들기\n\n```\n개인적으로 자취생들은 국이나 찌개를 만들어 먹는 것이 가장 힘들지 않은가 생각한다.\n먼가 1~2인분을 만들기도 어렵고 다른 요리보다 들어가는 재료나 조미료도 많은 경우가 많았다.\n그래서 항상 계란국이나 오뎅탕이나 만들다가 처음으로 미역국에 도전해 본다.\n재료는 적은데 맛은 최고인 가성비 국인듯 싶다\n```\n\n![이미지 준비중](<file:///Users/ballboy/workspace/project/static-site-generator/ver-node2/_dist/assets/img/이미지 준비중.png>)\n\n> 난이도 ✭✭\n> - 미역은 꼭 끓여 먹고\n소고기는 할인하면 꼭 사두자\n\n\n## 재료\n||재료명|용량(개수)|비고|양념(조미료)|용량(개수)|비고|\n|:-:|:--|:--|:--|:--|:--|:--|\n|1|건 미역|10g||국간장|3sp||\n|2|소고기|100g||액젓|1.5sp||\n|3||||참기름|2sp||\n\n\n## 레시피\n1. 미역을 물에 불린다.\n    - 불린 미역 양을 보고 더 넣거나 줄여도 좋다.\n\n1. 냄비에 참기름을 두르고 소고기를 넣어 중약불에 볶아 준다.\n\n1. 소고기가 익으면 불린 미역의 물을 짜고 함꼐 볶아 준다.\n\n1. 미역이 볶아지만 국간장을 넣고 계속 해서 볶아준다.\n    - 양조간장으로도 해 보았는데 가능은 하다\n\n1. 마지막으로 물을 넣고 액젓으로 간을 맞춘다.\n    - 미역국은 끓이고 시간이 지날수록 미역에서 짠맛이 우러나오니 생각보다 싱겁게 간을 맞추거나 짜지면 물을 넣고 다시 끓인다.\n\n1. 맛잇게 먹는다.\n\n\n~~~\n>> 자취생 평가 <<\n\n미역국에 마늘을 넣는 레시피가 많던데 개인 취향으로 마늘은 별로...\n~~~"}}},"dir_24":{"title":"면 러버의 면 사랑 요리","file":"","index":24,"count":1,"children":{"post_25":{"file":"내 멋대로 알리오 올리오","index":25,"path":"_post/자취생 밥 만들어 먹기_2/면 러버의 면 사랑 요리_24/내 멋대로 알리오 올리오.md","fold":["2","24"],"date":20250424,"content":"\n# 내 멋대로 알리오 올리오 만들기\n\n```\n자취생들에게 가장 쉬운 요리라고 하면 라면을 떠올리지 않을까 싶다.\n하지만 사실 파스타 역시 라면 만큼 쉽고 빠른 요리이다.\n특히나 알리오 올리오는 파스타 중에서도 정말 쉽고 발전 가능성이 무궁무진한 요리라고 생각한다.\n난 요즘은 집에 라면은 떨어져도 파스타 면은 절대 떨어 지지 않는다.\n오늘은 수많은 시행착오를 거치며 내 스타일에 맞는 알리오 올리오 파스타를 만들어 보겠다.\n단. 이탈리아 사람은 조용히 다른 요리 레시피를 구경하러 가는걸 추천한다.\n```\n\n![이미지 준비중](<file:///Users/ballboy/workspace/project/static-site-generator/ver-node2/_dist/assets/img/이미지 준비중.png>)\n\n> 난이도 ✭✭\n> - 라면 대신 파스타를!\n\n\n\n## 재료\n### 재료\n1. 파스타면 (링귀니면 추천) / 먹고 싶은 많큼\n1. 다진 마늘 / 3~4쪽\n1. 페퍼론치노 / 3~5개\n1. 냉동 새우살 / 먹고 싶은 많큼\n    - 필수는 아니고 버섯이나 고기 등 다른 재료도 가능하다.\n    - 이마트에 냉동 자숙 바지락살이 있는데 함께 쓰면 맛이 좋다.\n\n### 조미료\n1. 치킨스톡 / 반 티스푼 (1/4블록)\n1. 올리브유 / 적당량\n1. 후추, 소금 / 적당량\n1. 버터 / 1sp\n1. 치즈 / 적당량\n1. 파슬리 / 적당량\n\n\n\n\n## 레시피\n1. 냄비에 물을 500ml 정도 받치고 소금을 3~4꼬집 정도 넣는다.\n    \n2. 물이 팔팔 끓으면 면을 넣고 익힌다.\n    - 개인적으로 링귀니면을 추천한다. 면이 너무 얇지 않아 적당한 익힘을 맞추기 편하고 십는 식감도 좋았다.\n    - 아니면 페투치네 면도 나쁘지 않은 선택이다.\n\n3. 면을 5분정도 익히면 면수를 반컵정도만 남기고 모두 버린 다음 냄비 뚜껑을 닫아 둔다.\n    - 면의 자체 열기로 익히는 방법으로 흑백요리사의 히든 천재님의 방법을 참고 했다.\n\n4. 펜에 올리브유를 4sp정도 두르고 다진 마늘과 페퍼론치노를 함께 볶는다.\n    - 냉동 새우(버섯, 고기)가 있다면 이때 함께 볶아 준다.\n\n5. 새우가 익고 마늘이 점점 갈색 빛이 돌기 시작한다면 빼놓았던 면수를 부어주고 치킨스톡 넣고 끓여준다.\n\n6. 면수가 팔팔끓으면 면과 후추를 넣고 저어준다.\n    - 이때 냄비를 빠르게 설거지 한다.\n\n7. 버터 한덩이를 넣고 계속 저어주다가 치즈를 위에 뿌려준다.\n    - 치즈를 뿌리면 농도가 확! 되직해 지는데 너무 되직하면 면수나 생수를 넣고 더 저어준다.\n\n8. 마지막으로 소금으로 간을 맞추고 위체 파슬리를 뿌려준다.\n\n9. 맛있게 먹는다.\n\n\n~~~\n>> 자취생 평가 <<\n\n몇번하다보면 노하우가 생겨 라면 만큼 쉽고 라면보다 맛있다\n~~~"}}},"post_0":{"file":"자취생의 조미료 수집 리스트","index":0,"path":"_post/자취생 밥 만들어 먹기_2/자취생의 조미료 수집 리스트.md","fold":["2"],"date":20250425,"content":"\n# 자취생의 조미료 수집 리스트\n내가 직접 사서 사용해보면서 강추/비추하는 조미료 정리"},"dir_23":{"title":"한그릇으로 끝내는 덮밥, 소스","file":"","index":23,"count":4,"children":{"post_4":{"title":"강된장","file":"강된장","index":4,"path":"_post/자취생 밥 만들어 먹기_2/한그릇으로 끝내는 덮밥, 소스_23/강된장.md","fold":["2","23"],"date":20250319,"content":"\n# 강된장 만들기\n\n```\n유튜브를 보다보니 양배추를 사용하여 강된장을 끓이는 영상을 보았다.\n된장에 양배추라고 하니 어색한듯 하면서도 뭔가 맛있을것 같아서 도전해보았다.\n양배추 듬뿍 강된장 찌게 도전\n```\n\n![이미지 준비중](<file:///Users/ballboy/workspace/project/static-site-generator/ver-node2/_dist/assets/img/이미지 준비중.png>)\n\n### 난이도 ✭✭✭\n> 쌀 밥 한그릇 뚝딱!\n우렁을 넣으면 더 맛있을것 같다.\n\n\n## 재료\n||재료명|용량(개수)|비고|양념(조미료)|용량(개수)|비고|\n|:-:|:--|:--|:--|:--|:--|:--|\n|1|양배추|1/4통||된장|1.5sp||\n|2|양파|1/4통||고추장|0.5sp||\n|3|대파|1/3대||설탕|0.5sp||\n|4|다진마늘|2sp||식용유|1sp||\n|5|다진고기|100g|||||\n|6|팽이버섯|반봉|||||\n|7|청양고추|1~2개|||||\n|0|||||||\n\n\n## 레시피\n1. 양파와 양배추, 대파를 다져서 준비한다.\n\n1. 냄비에 식용유를 넣고 양파와 양배추, 대파를 중불에서 볶아준다.\n\n1. 야채가 읶기 시작하면 다진 고기를 넣고 함께 볶아 준다.\n\n1. 고기가 모두 읶으면 적당히 썷은 팽이버섯을 넣어준다.\n\n1. 설탕을 넣고 볶다가 된장과 고추장을 넣고 볶아준다.\n    - 중불에서 계속 볶았으면 야채와 버섯에서 수분이 나와 자작하겠지만 너무 되직하거나 촉촉한 된장을 원한다면 물(50ml)을 조금 넣어준다.\n\n1. 마지막으로 매운 맛을 원한다면 청양고추를 다져서 넣고 참기름과 통깨를 넣어 마무리 한다.\n\n1. 맛잇게 먹는다.\n\n\n~~~\n>> 자취생 평가 <<\n\n역시 한국인은 주기적으로 된장국을 먹어 줘야 한다.\n~~~"},"post_12":{"title":"삼겹살 덮밥","file":"삼겹살 덮밥","index":12,"path":"_post/자취생 밥 만들어 먹기_2/한그릇으로 끝내는 덮밥, 소스_23/삼겹살 덮밥.md","fold":["2","23"],"date":20250323,"content":"# 삼겹살 덮밥 만들기\n\n```\n밤에 유튜브를 보며 뒹굴거리다 출출해져 야식으로 무얼 먹을까 고민을 하는중 얼마전 이마트에서 기한이 얼마 남지 않아 40%나 세일을 하길레 얼른 주워온 삼겹살이 생각났다\n야식은 역시 맵고 짜고 단거 니까... 삼겹살 덮밥을 만들어 봤다.\n```\n\n![이미지 준비중](<file:///Users/ballboy/workspace/project/static-site-generator/ver-node2/_dist/assets/img/이미지 준비중.png>)\n\n### 난이도 ✭✭\n> 노브랜드 대패 삼겹살 말고 일반 삼겹살을 살 이유가 생겼다\n\n\n## 재료\n||재료명|용량(개수)|비고|양념(조미료)|용량(개수)|비고|\n|:-:|:--|:--|:--|:--|:--|:--|\n|1|삼겹살|1~2줄||양조간장|3sp||\n|2|마늘|5~10쪽|취향껏|설탕|1sp||\n|3|양파|1/4개||고추가루|1sp||\n|4|대파or쪽파|적당량||소금/후추|||\n|5|청양고추|1개|필수 아님||||\n\n\n## 레시피\n1. 삼겹살을 소금과 후추를 뿌려 구워준다.\n\n1. 구워진 삼겹살을 잠시 빼놓고 삼겹살 기름에 마늘과 채썬 양파를 넣고 볶아 준다.\n    - 마늘은 통마늘, 편마늘 모두 가능하다.\n\n1. 마늘과 양파가 적당량 볶아지면 삼겹살을 다시 넣고 팬 바깥쪽으로 간장을 3sp을 뿌려 졸여준다.\n    - 매콤한 맛을 원하면 청양고추 1개나 페퍼론치노 5개정도 넣어 함께 볶아준다.\n\n1. 팬에 설탕 1sp과 고추가루 1sp을 넣고 모든 재료를 잘 섞어 볶아준다. \n    - 고추가루가 떡이 지거나 재료가 잘 섞이지 않는다면 50ml 정도를 넣고 섞는다.\n\n1. 마지막으로 참기름을 살짝 부리고 잘게 썬 대파나 쪽파를 올린다.\n\n1. 밥위에 올려 덮밥이나 반찬으로 준비한다.\n\n1. 맛잇게 먹는다.\n\n\n~~~\n>> 자취생 평가 <<\n\n삼겹살이 맛있지만 대패나 국거리로 해도 맛이 괜찮다.\n~~~\n\n## 참고 자료/영상\n- [https://www.youtube.com/shorts/6Sd8bytvFPA](https://www.youtube.com/shorts/6Sd8bytvFPA)\n\n## 추가 내용\n- 2025-03-23\n    - 사실 삼겹살 야채와 함께 볶아도 맛있다.\n    - 대신 삼겹살이 오래 익으며 질겨지는 감은 있다."},"post_6":{"title":"진한 카레","file":"진한 카레","index":6,"path":"_post/자취생 밥 만들어 먹기_2/한그릇으로 끝내는 덮밥, 소스_23/진한 카레.md","fold":["2","23"],"date":20250320,"content":"\n# 카레 만들기 (1 ~ 2인분)\n\n```\n나는 카레를 좋아 한다. 특히 매콤하면서 돼지고기가 듬뿍 들어간 진한 카레를 매우 좋아하는데\n흔히 먹는 3분 카레는 진~한 맛이 없어 많이 아쉽다.\n그래서 내 취향대로 카레맛이 진~한 카레를 만들어 보았다.\n고기는 다다익선이다.\n```\n\n![이미지 준비중](<file:///Users/ballboy/workspace/project/static-site-generator/ver-node2/_dist/assets/img/이미지 준비중.png>)\n\n### 난이도 ✭✭\n> 걸~쭉하고 진~한 맛의 카레 만들기\n\n\n## 재료\n||재료명|용량(개수)|비고|양념(조미료)|용량(개수)|비고|\n|:-:|:--|:--|:--|:--|:--|:--|\n|1|감자|작은거 1개||블럭 카레|1블럭||\n|2|당근|취향 것||진간장|1.5sp||\n|3|양파|반개||굴소스|0.5sp||\n|4|고기150g|||큐민가루|0.3sp||\n|5|다진 마늘|1sp||후추|조금||\n|0|||||||\n\n\n## 레시피\n1. 감자와 당근 깨끗히 씩고 양파와 함께 적당한 크기의 다이스 형태로 썰어준다.\n    - 개인적으로 1cm 크기가 적당하다\n\n1. 냄비에 고기과 다진 마늘을 넣고 중불에서 볶아준다.\n\n1. 고기에서 붉은색이 없어 질때쯤 큐민 가루를 넣고 볶다가 다음으로 간장도 넣어 계속 볶아 준다.\n\n1. 고기가 익으면 당근과 감자, 양파를 모두 넣고 굴소스 0.5sp 을 넣어 준다.\n\n1. 양파가 볶아지고 당근이 익기 시작하면 물을 100ml 정도 넣어준다.\n\n1. 물이 끓고 감자가 익으면 고형 카레 한덩이와 후추를 넣고 계속 저으면서 감자와 당근이 취향에 맞게 익을때까지 끓여준다.\n    - 취향에 따라 물을 더 넣거나 졸여준다.\n\n1. 맛잇게 먹는다.\n\n\n~~~\n>> 자취생 평가 <<\n\n3분 카레 사러 편의점 갔다가 양파랑 당근 사서 집으로 돌아올 맛\n~~~\n\n## 참고 영상/자료\n- [https://www.youtube.com/shorts/Q0KJjfpk6YM](https://www.youtube.com/shorts/Q0KJjfpk6YM)\n\n## 추가 내용\n- 2025-03-20\n    - 감자가 없어 양송이 버섯을 깍둑썰어 넣어는데 별로..."},"post_14":{"title":"짜장소스","file":"짜장 소스","index":14,"path":"_post/자취생 밥 만들어 먹기_2/한그릇으로 끝내는 덮밥, 소스_23/짜장 소스.md","fold":["2","23"],"date":20250324,"content":"# 짜장 소스 만들기\n\n```\n나는 중국집 음식을 좋아한다.\n짜장면, 짬뽕, 냉짬뽕, 볶음밥, 울면, 사천짜장, 탕수육, 멘보샤, 군만두 등등\n음식을 거의 가리지 않는 나에게 중국집은 더 한단계 높은 일상속의 음식이다.\n그런데 요즘 배달 음식 가격이 너무 사악한데 짜장면 하나는 배달도 안하면서 1인 세트에 배달비 까지 하면 2만원이 쉽게 넘어 간다.\n이 정도면 짜장면은 더이상 서민의 음식이 아닌것 같다...\n결국! 여경옥 쉐프님과 짜장에 도전해본다.\n```\n\n![이미지 준비중](<file:///Users/ballboy/workspace/project/static-site-generator/ver-node2/_dist/assets/img/이미지 준비중.png>)\n\n### 난이도 ✭✭✭✭\n> 업소의 맛이란?\n\n<br/>\n\n## 재료\n||재료명|용량(개수)|비고|양념(조미료)|용량(개수)|비고|\n|:-:|:--|:--|:--|:--|:--|:--|\n|0|양파|한 개||춘장|듬뿍 1큰술||\n|0|돼지고기|150g||간장|1큰술||\n|0|다진 마늘|1큰술||굴소스|1큰술||\n|0|다진 생강|1/2큰술|난 생강이 없어 생강청을 넣고 설탕을 넣지 않았다.|설탕|0.5큰술||\n|0|완두콩|적당히?||전분||필수 아님|\n|0||||미원|쬐끔|필수 아님|\n|0||||식용유|||\n\n\n<br/>\n\n## 레시피\n1. 양파를 가로 세로 1cm 정도의 크기로 깍뚝 썰어 준다.\n\n1. 펜에 기름을 3~4큰술 정도 넉넉히 두르고 돼지고기와 다진 마늘, 다진 생강을 넣고 함께 볶는다.\n    - 난 다진 생강 대신 생강청이 있어 생강청을 넣고 설탕을 넣지 않았다.\n\n1. 돼지고기가 익기 시작하면 춘장을 넣고 함께 약 2분 정도 더 볶아준다.\n    - 펜에 남은 기름이 많이 없을 경우 기름을 추가 후 온도를 올리고 춘장을 넣어준다.\n\n1. 춘장을 기름에 볶아지면 썷어놓은 양파와 완두콩을 모두 넣고 간장, 굴소스, 설탕을 넣고 강불에 볶아준다.\n    - 거의 모든 유튜브나 자료에서는 미원을 반 꼬집 정도 넣어주면 엄청난 업소의 맛이 난다고 한다.\n\n1. 여기까지 간짜장으로 마무리 하거나, 옛날 짜장을 만들기 위해서는 물을 100ml정도 넣어주고 더 볶다가 물전분을 넣고 농도를 잡아주고 마무리 한다.\n\n1. 맛잇게 먹는다.\n\n<br/>\n\n~~~\n>> 자취생 평가 <<\n\n걱정 했던것 보다는 맛이 좋았다. 몇번 더 해먹으면서 노하우가 쌓이면 더 맛있어 질것 같다.\n~~~\n\n## 참고 자료/영상\n- [이연복 쉐프님](https://www.youtube.com/watch?v=tQUTkWfHdO8&t=1s)\n- [여경옥 쉐프님](https://www.youtube.com/watch?v=FJr-9TncbrM&t=414s)\n    - 여경옥 쉐프님의 레시피가 자취생에게 가장 알맞은거 같았다.\n\n## 추가 내용\n- 2025-03-24\n    - 왜 난 미원을 넣으니까 더 맛이 없지?"}}}}}}